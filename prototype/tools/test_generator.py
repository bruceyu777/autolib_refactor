"""
Test Generator Module
Handles generation of pytest test files from parsed DSL
"""

import re
from pathlib import Path
from typing import List, Dict, Optional, Tuple


class TestGenerator:
    """Generate pytest test files from DSL structure"""
    
    def __init__(self):
        """Initialize test generator"""
        pass
    
    def generate_test_header(self, qaid: str, original_file: Path, helper_names: List[str] = None) -> str:
        """
        Generate test file header with helper imports
        
        Args:
            qaid: Test QAID identifier
            original_file: Path to original DSL file
            helper_names: List of helper function names to import
            
        Returns:
            String containing test file header with imports
        """
        header = f'''"""
Auto-generated pytest test for QAID {qaid}

Original DSL: {original_file}
Generated by: DSL Transpiler
"""

import pytest
from pathlib import Path
'''
        
        # Add helper imports if any
        if helper_names:
            header += '\n# Import helper functions from converted includes\n'
            for helper_name in sorted(set(helper_names)):
                header += f'from testcases.helpers.{helper_name} import {helper_name}\n'
        
        return header + '\n'
    
    def generate_test_function(self, parsed: dict, helper_names: List[str] = None) -> str:
        """
        Generate complete pytest test function from parsed DSL
        
        Args:
            parsed: Parsed DSL structure with qaid, title, sections, includes
            helper_names: List of helper function names used in test
            
        Returns:
            String containing complete test function code
        """
        qaid = parsed['qaid']
        title = parsed.get('title', qaid)
        sections = parsed.get('sections', [])
        
        # Sanitize test name
        sanitized_qaid = self.sanitize_identifier(qaid)
        
        # Build parameter list (testbed is always first, logger is optional but recommended)
        params = ['testbed', 'logger']
        param_str = ', '.join(params)
        
        # Build function header
        func = f'''

def test_{sanitized_qaid}({param_str}):
    """
    {title}
    
    QAID: {qaid}
    """
'''
        
        # Add test execution
        func += '    # Execute test sections\n'
        
        if not sections:
            func += '    # No sections found in DSL file\n'
            func += '    logger.warning("No test sections found")\n'
            func += '    pass\n'
        else:
            for idx, section in enumerate(sections):
                device = section.get('device', 'UNKNOWN')
                commands = section.get('commands', [])
                
                # Convert section to pytest code
                section_code = self.convert_section(section, qaid)
                func += section_code
        
        # Add test completion marker
        func += '''
    # Test completed
    logger.info("="*60)
    logger.info(f"QAID {qaid}: Test Completed (Mock Mode)")
    logger.info("="*60)
'''
        
        return func
    
    def convert_section(self, section: dict, qaid: str, indent: str = "    ") -> str:
        """
        Convert a DSL section to pytest code
        
        Args:
            section: Dictionary with 'device' and 'commands'
            qaid: Test QAID for context
            indent: Indentation string
            
        Returns:
            String containing pytest code for the section
        """
        device = section.get('device', 'UNKNOWN')
        commands = section.get('commands', [])
        
        code = f'\n{indent}# Section: {device}\n'
        code += f'{indent}device = testbed.switch("{device}")\n'
        
        # Group and convert commands
        blocks = self._group_commands(commands)
        code += self._convert_blocks(blocks, qaid, 'device', indent)
        
        return code
    
    def _group_commands(self, commands: List[str]) -> List[dict]:
        """
        Group commands into logical blocks (conditionals, loops, regular commands)
        
        Args:
            commands: List of command strings
            
        Returns:
            List of block dictionaries with type and content
        """
        blocks = []
        idx = 0
        
        while idx < len(commands):
            line = commands[idx].strip()
            
            # Skip empty lines and comments
            if not line or line.startswith('#'):
                idx += 1
                continue
            
            # Check for conditional blocks (if, elseif, else)
            if line.startswith('if(') or line.startswith('if ('):
                # Find matching endif
                end_idx = self._find_block_end(commands, idx, 'if', 'endif')
                
                # Extract condition
                condition_str = line[2:].strip()
                if condition_str.startswith('(') and ')' in condition_str:
                    condition_str = condition_str[1:condition_str.index(')')]
                
                # Parse condition
                condition = self._parse_condition(condition_str)
                
                # Find elseif/else within the block
                elseif_else_tags = self._find_elseif_else_tags(commands, idx + 1, end_idx)
                
                # Build conditional block structure
                conditional_block = {
                    'type': 'conditional',
                    'condition': condition,
                    'then_commands': [],
                    'elseif_blocks': [],
                    'else_commands': []
                }
                
                # Extract then commands (between if and first elseif/else/endif)
                then_end = elseif_else_tags[0]['idx'] if elseif_else_tags else end_idx
                conditional_block['then_commands'] = commands[idx + 1:then_end]
                
                # Process elseif/else blocks
                for i, tag in enumerate(elseif_else_tags):
                    tag_line = commands[tag['idx']].strip()
                    next_tag_idx = elseif_else_tags[i + 1]['idx'] if i + 1 < len(elseif_else_tags) else end_idx
                    
                    if tag_line.startswith('elseif'):
                        # Extract elseif condition
                        elseif_condition_str = tag_line[6:].strip()
                        if elseif_condition_str.startswith('(') and ')' in elseif_condition_str:
                            elseif_condition_str = elseif_condition_str[1:elseif_condition_str.index(')')]
                        
                        elseif_condition = self._parse_condition(elseif_condition_str)
                        conditional_block['elseif_blocks'].append({
                            'condition': elseif_condition,
                            'commands': commands[tag['idx'] + 1:next_tag_idx]
                        })
                    
                    elif tag_line.startswith('else'):
                        conditional_block['else_commands'] = commands[tag['idx'] + 1:next_tag_idx]
                
                blocks.append(conditional_block)
                idx = end_idx + 1
                continue
            
            # Check for include directives (already processed, skip)
            if line.startswith('include '):
                idx += 1
                continue
            
            # Regular command
            blocks.append({
                'type': 'command',
                'command': line
            })
            idx += 1
        
        return blocks
    
    def _find_block_end(self, commands: List[str], start_idx: int, start_tag: str, end_tag: str) -> int:
        """
        Find the matching end tag for a block structure
        
        Args:
            commands: List of command strings
            start_idx: Index where block starts
            start_tag: Starting tag (e.g., 'if', 'for')
            end_tag: Ending tag (e.g., 'endif', 'endfor')
            
        Returns:
            Index of the matching end tag
        """
        depth = 1
        idx = start_idx + 1
        
        while idx < len(commands) and depth > 0:
            line = commands[idx].strip()
            
            # Check for nested start tags
            if line.startswith(start_tag + '(') or line.startswith(start_tag + ' '):
                depth += 1
            # Check for end tags
            elif line.startswith(end_tag):
                depth -= 1
            
            idx += 1
        
        return idx - 1 if depth == 0 else len(commands) - 1
    
    def _find_elseif_else_tags(self, commands: List[str], start_idx: int, end_idx: int) -> List[dict]:
        """
        Find elseif/else tags within an if block
        
        Args:
            commands: List of command strings
            start_idx: Start index to search from
            end_idx: End index to search to
            
        Returns:
            List of dictionaries with tag information
        """
        tags = []
        depth = 0
        
        for idx in range(start_idx, end_idx):
            line = commands[idx].strip()
            
            # Track nested if blocks
            if line.startswith('if(') or line.startswith('if '):
                depth += 1
            elif line.startswith('endif'):
                depth -= 1
            # Only capture elseif/else at depth 0 (same level as original if)
            elif depth == 0 and (line.startswith('elseif') or line == 'else'):
                tags.append({'idx': idx, 'tag': line.split('(')[0].strip()})
        
        return tags
    
    def _parse_condition(self, condition_str: str) -> dict:
        """
        Parse condition string into structured format
        
        Args:
            condition_str: Condition string from DSL
            
        Returns:
            Dictionary with condition structure
        """
        # Remove extra whitespace
        condition_str = condition_str.strip()
        
        # Simple parsing for common patterns
        # Pattern: VAR == "value" or VAR != "value"
        match = re.match(r'^(\w+)\s*(==|!=|>|<|>=|<=)\s*(.+)$', condition_str)
        if match:
            var, op, value = match.groups()
            # Remove quotes from value if present
            value = value.strip().strip('"').strip("'")
            return {
                'type': 'comparison',
                'variable': var,
                'operator': op,
                'value': value
            }
        
        # Default: return as expression
        return {
            'type': 'expression',
            'expression': condition_str
        }
    
    def _translate_condition_to_python(self, condition: dict, device_var: Optional[str] = None) -> str:
        """
        Translate condition structure to Python code
        
        Args:
            condition: Parsed condition dictionary
            device_var: Variable name for device object
            
        Returns:
            Python condition string
        """
        if condition['type'] == 'comparison':
            var = condition['variable']
            op = condition['operator']
            value = condition['value']
            
            # Check if variable is a device variable
            if device_var and var.startswith('$'):
                # This might be a variable we need to resolve
                var_name = var.lstrip('$')
                python_cond = f'{var_name} {op} "{value}"'
            else:
                # Simple comparison
                python_cond = f'"{var}" {op} "{value}"'
            
            return python_cond
        
        # Default: return expression as-is (may need more sophisticated handling)
        return condition.get('expression', 'True')
    
    def _convert_blocks(self, blocks: List[dict], qaid: str, device_var: str, indent: str) -> str:
        """
        Convert command blocks to pytest code
        
        Args:
            blocks: List of command blocks
            qaid: Test QAID for context
            device_var: Variable name for device
            indent: Indentation string
            
        Returns:
            String containing pytest code
        """
        code = ''
        
        for block in blocks:
            block_type = block.get('type')
            
            if block_type == 'command':
                # Regular command
                command = block.get('command', '')
                if command:
                    # Resolve variables in command
                    resolved_cmd, has_vars = self._resolve_variables(command, device_var)
                    code += f'{indent}{device_var}.execute({self._quote_command(resolved_cmd)})\n'
            
            elif block_type == 'conditional':
                # Conditional block (if/elseif/else)
                condition = block.get('condition', {})
                python_cond = self._translate_condition_to_python(condition, device_var)
                
                code += f'{indent}if {python_cond}:\n'
                
                # Then block
                then_commands = block.get('then_commands', [])
                then_blocks = self._group_commands(then_commands)
                code += self._convert_blocks(then_blocks, qaid, device_var, indent + '    ')
                
                if not then_blocks:
                    code += f'{indent}    pass\n'
                
                # Elseif blocks
                for elseif in block.get('elseif_blocks', []):
                    elseif_cond = self._translate_condition_to_python(elseif['condition'], device_var)
                    code += f'{indent}elif {elseif_cond}:\n'
                    elseif_blocks = self._group_commands(elseif['commands'])
                    code += self._convert_blocks(elseif_blocks, qaid, device_var, indent + '    ')
                    
                    if not elseif_blocks:
                        code += f'{indent}    pass\n'
                
                # Else block
                else_commands = block.get('else_commands', [])
                if else_commands:
                    code += f'{indent}else:\n'
                    else_blocks = self._group_commands(else_commands)
                    code += self._convert_blocks(else_blocks, qaid, device_var, indent + '    ')
                    
                    if not else_blocks:
                        code += f'{indent}    pass\n'
        
        return code
    
    def _resolve_variables(self, text: str, device_var: str = "device") -> Tuple[str, bool]:
        """
        Resolve DSL variables in text
        
        Args:
            text: Text containing potential variables
            device_var: Variable name for device object
            
        Returns:
            Tuple of (resolved_text, has_variables)
        """
        has_vars = False
        
        def replace_var(match):
            nonlocal has_vars
            has_vars = True
            var_name = match.group(1)
            # For now, just return the variable as-is
            # In production, this would lookup the variable value
            return f'{{{var_name}}}'
        
        # Replace $VARIABLE patterns
        resolved = re.sub(r'\$([A-Z_][A-Z0-9_]*)', replace_var, text)
        
        return resolved, has_vars
    
    def _quote_command(self, command: str) -> str:
        """
        Properly quote a command string for Python
        
        Args:
            command: Command string
            
        Returns:
            Quoted command string
        """
        # Escape backslashes and quotes
        escaped = command.replace('\\', '\\\\').replace('"', '\\"')
        return f'"{escaped}"'
    
    @staticmethod
    def sanitize_identifier(name: str) -> str:
        """
        Convert string to valid Python identifier
        
        Args:
            name: String to sanitize
            
        Returns:
            Valid Python identifier
        """
        # Replace hyphens and other invalid chars with underscores
        sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
        # Ensure it doesn't start with a digit
        if sanitized and sanitized[0].isdigit():
            sanitized = '_' + sanitized
        return sanitized
